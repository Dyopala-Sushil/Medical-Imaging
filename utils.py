import matplotlib.pyplot as plt
import matplotlib.animation as animation
import numpy as np
import torch
from monai.inferers import sliding_window_inference
from monai.transforms import (
    AsDiscrete,
    Compose,
    CropForeground,
    LoadImage,
    Orientation,
    ScaleIntensityRange,
    Spacing
)
from model import getModel

def load_model(path2state, device):
    """
    Loads the trained model
    """
    model = getModel(device)
    model_state = torch.load(path2state)
    model.load_state_dict(model_state)
    return model



def preprocess_data(path2data):
    """
    Preprocess the input volumes as per the validation preprocessing steps
    """
    val_transforms = Compose(
        [
            LoadImage(image_only=True, ensure_channel_first=True),
            ScaleIntensityRange(
                a_min=-57, a_max=164,
                b_min=0.0, b_max=1.0, clip=True,
            ),
            CropForeground(),
            Orientation(axcodes="RAS"),
            Spacing(pixdim=(1.5, 1.5, 2.0), mode=("bilinear")),
        ]
    )

    return val_transforms(path2data)

def post_process_prediction(predicted_seg_mask):
   """
    Returns two channeled image for bg and fg
   """
   return AsDiscrete(argmax=True, to_onehot=2)(predicted_seg_mask)

def get_prediction_masks(processed_volume, model, device):
    """
    Generates the segmentaion mask using trained model
    """

    # Setting model in eval mode
    model.eval()

    # Segementation masks generated by model
    predicted_seg_masks = sliding_window_inference(
                processed_volume.to(device), 
                roi_size=(160, 160, 160), 
                sw_batch_size=4, 
                predictor=model
            )
    return predicted_seg_masks

# Function for displaying single slice of image and label from volume
def display_single_pair(image, label, slice_num):
  """
  Displays the single slice of image and label from volume

  Args:
    image: input image of shape (C, H, W, D)
    label: label corresponding to image of same shape

  """
  plt.figure(figsize=(8,5))
  plt.subplot(1, 2, 1)
  plt.imshow(image[0,:,:,slice_num], cmap="gray")
  plt.title(f"Image_{slice_num}")
  plt.axis("off")
  plt.subplot(1, 2, 2)
  plt.imshow(label[0,:,:,slice_num], cmap="gray")
  plt.title(f"Label_{slice_num}")
  plt.axis("off")
  plt.show()


def overlay_mask(image, mask_bg, mask_fg):
  """
  Overlays mask over image and returns the segmented image

  Args:
    image: numy array of shape (H, W, D)
    mask_bg: numy array of shape (H, W, D)
    mask_fg: numy array of shape (H, W, D)

  Returns:
    seg_img: numpy array of shape (H, W, D, 3)
  """
  # Creating seg_img 4D array with 3 channels
  seg_img = np.zeros((image.shape[0], image.shape[1],image.shape[2], 3), dtype=image.dtype)
  seg_img[...,0] = image[...]
  seg_img[...,1] = image[...]
  seg_img[...,2] = image[...]

  # Removing the spleen region
  seg_img[...,0] *= mask_bg
  seg_img[...,1] *= mask_bg
  seg_img[...,2] *= mask_bg
  
  # Applying foreground mask
  seg_img[...,0] += mask_fg * 255

  return seg_img

def save_segmented_result(seg_img):
  frames = [] # for storing the generated images
  fig = plt.figure()
  plt.axis("off")
  for i in range(seg_img.shape[-2]):
      frames.append([plt.imshow(np.clip(seg_img[:,:,i], 0, 1), cmap="plasma",animated=True)])

  ani = animation.ArtistAnimation(fig, frames, interval=100, blit=True,repeat_delay=2000)
  ani.save('result.gif', writer="pillow")
  plt.show()